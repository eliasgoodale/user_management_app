{"ast":null,"code":"import isPromise from 'is-promise';\nimport _ from 'underscore';\nexport default function errorMiddleware() {\n  return function (next) {\n    return function (action) {\n      var types = {\n        FOO: true\n      }; // If not a promise, continue on\n\n      if (!isPromise(action.payload)) {\n        return next(action);\n      }\n      /*\n       * Another solution would would be to include a property in `meta`\n       * and evaulate that property.\n       *\n       * if (action.meta.globalError === true) {\n       *   // handle error\n       * }\n       *\n       * The error middleware serves to dispatch the initial pending promise to\n       * the promise middleware, but adds a `catch`.\n       */\n\n\n      if (_.has(types, action.type)) {\n        // Dispatch initial pending promise, but catch any errors\n        return next(action).catch(function (error) {\n          console.warn(error);\n          return error;\n        });\n      }\n\n      return next(action);\n    };\n  };\n}","map":{"version":3,"sources":["/nfs/2018/e/egoodale/RDT/user_management_app/app/src/middleware/index.ts"],"names":["isPromise","_","errorMiddleware","next","action","types","FOO","payload","has","type","catch","error","console","warn"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,YAAtB;AACA,OAAOC,CAAP,MAAc,YAAd;AAEA,eAAe,SAASC,eAAT,GAA2B;AACxC,SAAO,UAACC,IAAD;AAAA,WAAe,UAACC,MAAD,EAAiB;AACrC,UAAMC,KAAK,GAAG;AACZC,QAAAA,GAAG,EAAE;AADO,OAAd,CADqC,CAKrC;;AACA,UAAI,CAACN,SAAS,CAACI,MAAM,CAACG,OAAR,CAAd,EAAgC;AAC9B,eAAOJ,IAAI,CAACC,MAAD,CAAX;AACD;AAED;;;;;;;;;;;;;AAWA,UAAIH,CAAC,CAACO,GAAF,CAAMH,KAAN,EAAaD,MAAM,CAACK,IAApB,CAAJ,EAA+B;AAE7B;AACA,eAAON,IAAI,CAACC,MAAD,CAAJ,CAAaM,KAAb,CAAmB,UAACC,KAAD,EAAgB;AACxCC,UAAAA,OAAO,CAACC,IAAR,CAAaF,KAAb;AAEA,iBAAOA,KAAP;AACD,SAJM,CAAP;AAKD;;AAED,aAAOR,IAAI,CAACC,MAAD,CAAX;AACD,KAhCM;AAAA,GAAP;AAiCD","sourcesContent":["import isPromise from 'is-promise';\nimport _ from 'underscore';\n\nexport default function errorMiddleware() {\n  return (next: any) => (action: any) => {\n    const types = {\n      FOO: true,\n    };\n\n    // If not a promise, continue on\n    if (!isPromise(action.payload)) {\n      return next(action);\n    }\n\n    /*\n     * Another solution would would be to include a property in `meta`\n     * and evaulate that property.\n     *\n     * if (action.meta.globalError === true) {\n     *   // handle error\n     * }\n     *\n     * The error middleware serves to dispatch the initial pending promise to\n     * the promise middleware, but adds a `catch`.\n     */\n    if (_.has(types, action.type)) {\n\n      // Dispatch initial pending promise, but catch any errors\n      return next(action).catch((error: any) => {\n        console.warn(error);\n\n        return error;\n      });\n    }\n\n    return next(action);\n  };\n}"]},"metadata":{},"sourceType":"module"}