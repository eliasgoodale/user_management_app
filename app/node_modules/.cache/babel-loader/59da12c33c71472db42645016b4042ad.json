{"ast":null,"code":"/**\n * @hidden\n */\nvar VirtualScroll =\n/** @class */\nfunction () {\n  function VirtualScroll(cached) {\n    this.containerHeight = 0;\n    this.topCacheCount = 0; // 4;\n\n    this.attendedSkip = 0; // -4;\n\n    this.propsSkip = 0;\n    this.total = 0;\n    this.scrollableVirtual = false;\n    this.realSkip = 0;\n    this.pageSize = 0;\n    this.heightContainer = null;\n    this.prevScrollPos = 0;\n    this.tableTranslate = 0;\n    this.scrollSyncing = false;\n\n    if (cached) {\n      this.topCacheCount = 4;\n      this.attendedSkip = -this.topCacheCount;\n    }\n\n    this.scrollHandler = this.scrollHandler.bind(this);\n  }\n  /**\n   * @return - The row heights in an array.\n   */\n\n\n  VirtualScroll.prototype.rowHeights = function () {\n    var rowHeights = [];\n    var allRows = this.tableBody && this.tableBody.children || [];\n\n    for (var i = 0; i < allRows.length; i++) {\n      if (allRows[i].className.indexOf('k-detail-row') > -1) {\n        rowHeights[rowHeights.length - 1] += allRows[i].scrollHeight;\n      } else {\n        rowHeights.push(allRows[i].scrollHeight);\n      }\n    }\n\n    return rowHeights;\n  };\n\n  VirtualScroll.prototype.changePage = function (skip, e) {\n    this.attendedSkip = skip - this.topCacheCount;\n    this.PageChange({\n      skip: Math.max(0, skip - this.topCacheCount),\n      take: this.pageSize\n    }, e);\n  };\n\n  VirtualScroll.prototype.translate = function (dY) {\n    this.tableTranslate = dY;\n\n    if (this.table) {\n      this.table.style.transform = 'translateY(' + dY + 'px)';\n    }\n  };\n\n  VirtualScroll.prototype.syncScroll = function () {\n    if (!this.scrollableVirtual || !this.container) {\n      return;\n    }\n\n    this.syncTimeout = null;\n    this.scrollSyncing = true;\n    var scrollTop = this.container.scrollTop;\n    var containerHeight = this.containerHeight; // = this.container.scrollHeight;\n\n    var rowHeights = this.rowHeights();\n    var percentage = (scrollTop - this.tableTranslate) / rowHeights[0];\n    var targetFloorScrollPosition = Math.floor(containerHeight * (this.propsSkip + percentage) / this.total);\n    this.container.scrollTop = this.prevScrollPos = targetFloorScrollPosition;\n    this.translate(this.tableTranslate + targetFloorScrollPosition - scrollTop);\n  };\n\n  VirtualScroll.prototype.reset = function () {\n    this.scrollSyncing = true;\n\n    if (this.container) {\n      this.container.scrollTop = 0;\n    }\n\n    this.translate(0);\n  };\n\n  VirtualScroll.prototype.localScrollUp = function (e) {\n    if (!this.container) {\n      return;\n    }\n\n    var heights = this.rowHeights();\n    var scrollTop = this.container.scrollTop;\n    var targetTranslate = this.tableTranslate;\n    var rowsCount;\n    var additionalOnTop = scrollTop - targetTranslate;\n\n    if (additionalOnTop > 0) {\n      return;\n    }\n\n    for (rowsCount = 0; rowsCount < this.topCacheCount + this.attendedSkip - this.realSkip && this.propsSkip - rowsCount > 0; rowsCount++) {\n      if (targetTranslate + heights[heights.length - 1 - rowsCount] + additionalOnTop <= scrollTop) {\n        break;\n      }\n\n      targetTranslate -= heights[heights.length - 1 - rowsCount];\n    }\n\n    if (rowsCount === 0 && this.topCacheCount === 0 && this.attendedSkip > 0) {\n      // allows local scrolling up, when top caching is disabled\n      // for variable heights 'topCacheCount' should be atleast 1 to avoid flickering\n      targetTranslate = Math.max(targetTranslate - heights[0], 0);\n      rowsCount = 1;\n    }\n\n    if (this.propsSkip - rowsCount <= 0 && targetTranslate > scrollTop) {\n      this.translate(0);\n      this.changePage(0, e);\n      this.container.scrollTop = 0;\n      return;\n    }\n\n    if (targetTranslate > scrollTop) {\n      targetTranslate = scrollTop; // need to handle these cases\n      // if the item height is not available:\n      //    floor the translate to beginning of the item in absolute value\n    }\n\n    if (targetTranslate !== this.tableTranslate) {\n      this.translate(targetTranslate);\n      this.changePage(this.propsSkip - rowsCount, e);\n    }\n  };\n\n  VirtualScroll.prototype.localScrollDown = function (e) {\n    if (!this.container) {\n      return;\n    }\n\n    var heights = this.rowHeights();\n    var scrollTop = this.container.scrollTop;\n    var targetTranslate = this.tableTranslate;\n    var rowsCount;\n\n    for (rowsCount = 0; rowsCount < heights.length - this.topCacheCount; rowsCount++) {\n      if (targetTranslate + heights[rowsCount] > scrollTop) {\n        break;\n      }\n\n      targetTranslate += heights[rowsCount];\n    }\n\n    if (rowsCount >= heights.length - this.topCacheCount && this.propsSkip + rowsCount >= this.total) {\n      this.translate(targetTranslate);\n      this.changePage(this.total - 1, e);\n    } else if (targetTranslate !== this.tableTranslate) {\n      this.translate(targetTranslate);\n      this.changePage(this.propsSkip + rowsCount, e);\n    }\n  };\n\n  VirtualScroll.prototype.scrollNonStrict = function (e) {\n    var floatRowIndex = this.total * this.prevScrollPos / this.containerHeight;\n    var rowIndex = Math.floor(floatRowIndex);\n\n    if (rowIndex >= this.total) {\n      rowIndex = this.total - 1;\n    }\n\n    var rowpercentage = Math.min(floatRowIndex - rowIndex, 1);\n    var microAdjust = 0;\n    var rowIndexOffset = rowIndex - this.propsSkip;\n    var heights = this.rowHeights();\n\n    if (rowIndexOffset >= 0 && rowIndexOffset <= 1) {\n      microAdjust = -heights[0] * rowpercentage;\n    } else if (rowIndexOffset === -1) {\n      microAdjust = -heights[heights.length - 1] * rowpercentage;\n    }\n\n    this.translate(microAdjust + this.containerHeight * floatRowIndex / this.total);\n    this.changePage(rowIndex, e);\n  };\n\n  VirtualScroll.prototype.scrollHandler = function (e) {\n    if (!this.scrollableVirtual) {\n      return;\n    }\n\n    if (this.scrollSyncing || !this.container || !this.table) {\n      this.scrollSyncing = false;\n      return;\n    }\n\n    var grid = this;\n    clearTimeout(this.syncTimeout);\n    this.syncTimeout = setTimeout(function () {\n      grid.syncScroll();\n    }, 200);\n    var scrollTop = this.container.scrollTop;\n    var prev = this.prevScrollPos;\n    this.prevScrollPos = scrollTop;\n\n    if (scrollTop - prev < 0 && scrollTop > this.tableTranslate - this.table.scrollHeight / 10) {\n      this.localScrollUp(e);\n    } else if (scrollTop - prev > 0 && scrollTop < this.tableTranslate + this.table.scrollHeight * 2 / 3) {\n      this.localScrollDown(e);\n    } else {\n      this.scrollNonStrict(e);\n    }\n\n    this.prevScrollPos = scrollTop;\n  };\n\n  return VirtualScroll;\n}();\n\nexport { VirtualScroll };","map":null,"metadata":{},"sourceType":"module"}