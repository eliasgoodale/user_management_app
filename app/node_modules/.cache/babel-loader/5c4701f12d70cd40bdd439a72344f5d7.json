{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { classNames, guid, noop, Keys, dispatchEvent } from '@progress/kendo-react-common';\nimport { throttle, FRAME_DURATION } from './util';\nimport SwitchController from '../common/SwitchController';\nimport Draggable from '@telerik/kendo-draggable';\nvar SWITCH_CONTAINER = 'k-switch-container';\nvar SWITCH_HANDLE = 'k-switch-handle';\nvar SWITCH_LABEL_ON = 'k-switch-label-on';\nvar SWITCH_LABEL_OFF = 'k-switch-label-off';\n/**\n * Represents the [KendoReact Switch component]({% slug overview_switch%}).\n */\n\nvar Switch =\n/** @class */\nfunction (_super) {\n  __extends(Switch, _super);\n  /**\n   * @hidden\n   */\n\n\n  function Switch(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._id = guid();\n\n    _this.handleKeyDown = function (event) {\n      _this.ifEnabled(function () {\n        var keyCode = event.keyCode;\n\n        if (keyCode === Keys.space || keyCode === Keys.enter) {\n          _this._controller.change(!_this.state.checked, event);\n        }\n      });\n    };\n\n    _this.handleWrapperFocus = function (event) {\n      _this.setState({\n        focused: true\n      });\n\n      _this.ifEnabled(_this.props.onFocus, event);\n    };\n\n    _this.handleWrapperBlur = function (event) {\n      _this.setState({\n        focused: false\n      });\n\n      _this.ifEnabled(_this.props.onBlur, event);\n    };\n\n    _this.handleResize = function (_) {\n      _this.updateControllerState();\n    };\n\n    _this.handleDrag = function (event) {\n      _this.ifEnabled(_this._controller.onDrag, event);\n    };\n\n    _this.handlePress = function (event) {\n      _this.ifEnabled(_this._controller.onPress, event);\n    };\n\n    _this.handleRelease = function (event) {\n      _this.ifEnabled(_this._controller.onRelease, event);\n    };\n\n    _this.handleChangeValue = function (value, event) {\n      var checked = _this.props.checked !== undefined ? _this.props.checked : value; // The actual value is in the state.\n\n      if (_this.state.checked !== checked) {\n        _this.setState({\n          checked: checked\n        }, function () {\n          _this.valueDuringOnChange = undefined;\n        });\n      } // The value that is coming form the controller.\n      // The controller should not be aware if we are in\n      // a controlled or uncontrolled state, so we update it.\n\n\n      if (_this._controller.checked !== checked) {\n        _this._controller.change(checked);\n      } // If the user is not aware of the next suggested value,\n      // we present it in the onChange event.\n      // The onChange event is called every time when the component is\n      // in an uncontrolled state.\n\n\n      if (_this.props.checked !== value) {\n        _this.valueDuringOnChange = value;\n        dispatchEvent(_this.props.onChange, event, _this, {\n          value: value\n        });\n      }\n    };\n\n    _this.ifEnabled = function (callback, event) {\n      if (!_this.props.disabled) {\n        callback(event);\n      }\n    };\n\n    _this.updateView = function (elements) {\n      if (_this._drag) {\n        _this.applyStyle(_this._controller.addAnimation(elements.handle), _this._drag);\n      }\n    };\n\n    _this.applyStyle = function (props, drag) {\n      Object.keys(props).forEach(function (x) {\n        drag.style[x] = props[x];\n      });\n    };\n\n    _this.state = {\n      checked: props.checked !== undefined ? props.checked : props.defaultChecked,\n      focused: false\n    };\n    _this._controller = new SwitchController(_this.updateView, _this.handleChangeValue);\n    _this.handleResize = throttle(_this.handleResize, FRAME_DURATION);\n    return _this;\n  }\n\n  Object.defineProperty(Switch.prototype, \"value\", {\n    /**\n     * Gets the value of the Switch.\n     */\n    get: function get() {\n      return this.valueDuringOnChange !== undefined ? this.valueDuringOnChange : this.state.checked;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Switch.prototype, \"element\", {\n    get: function get() {\n      return this._element;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n\n  Switch.prototype.componentDidUpdate = function () {\n    if (this.props.checked !== undefined && this.props.checked !== this.state.checked) {\n      this._controller.change(this.props.checked);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Switch.prototype.componentDidMount = function () {\n    if (!this._element) {\n      return;\n    }\n\n    this._draggable = new Draggable({\n      drag: this.handleDrag,\n      press: this.handlePress,\n      release: this.handleRelease\n    });\n\n    this._draggable.bindTo(this._element);\n\n    this.updateControllerState();\n    window.addEventListener('resize', this.handleResize);\n    this.forceUpdate();\n  };\n  /**\n   * @hidden\n   */\n\n\n  Switch.prototype.componentWillUnmount = function () {\n    if (this._draggable && this._draggable.destroy) {\n      this._draggable.destroy();\n    }\n\n    window.removeEventListener('resize', this.handleResize);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Switch.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.state,\n        focused = _a.focused,\n        checked = _a.checked;\n    var _b = this.props,\n        dir = _b.dir,\n        disabled = _b.disabled,\n        id = _b.id,\n        offLabel = _b.offLabel,\n        onLabel = _b.onLabel,\n        tabIndex = _b.tabIndex;\n    var direction = dir || this._wrapper && getComputedStyle(this._wrapper).direction || undefined;\n    var switchClassName = classNames({\n      'k-widget': true,\n      'k-switch': true,\n      'k-switch-on': checked,\n      'k-switch-off': !checked,\n      'k-state-focused': focused,\n      'k-state-disabled': disabled\n    }, this.props.className);\n    var ariaAttributes = {\n      'aria-checked': checked,\n      'aria-disabled': disabled || undefined\n    };\n    return React.createElement(\"span\", __assign({\n      className: switchClassName,\n      dir: direction,\n      onKeyDown: this.handleKeyDown,\n      ref: function ref(span) {\n        _this._wrapper = span;\n      }\n    }, ariaAttributes), React.createElement(\"span\", {\n      className: SWITCH_CONTAINER,\n      id: id || this._id,\n      onBlur: this.handleWrapperBlur,\n      onFocus: this.handleWrapperFocus,\n      ref: function ref(span) {\n        _this._element = span;\n      },\n      tabIndex: disabled ? undefined : tabIndex\n    }, React.createElement(\"span\", {\n      className: SWITCH_HANDLE,\n      ref: function ref(span) {\n        _this._drag = span;\n      }\n    }, React.createElement(\"span\", {\n      className: SWITCH_LABEL_ON\n    }, onLabel), React.createElement(\"span\", {\n      className: SWITCH_LABEL_OFF\n    }, offLabel))));\n  };\n\n  Switch.prototype.updateControllerState = function () {\n    if (!this._element || !this._wrapper || !this._drag || !window) {\n      return;\n    }\n\n    var handleElement = this._drag;\n    var handleStyles = window.getComputedStyle(handleElement);\n    var handleMargin = (parseInt(handleStyles.marginLeft || '0', 10) + parseInt(handleStyles.borderLeftWidth || '0', 10)) * 2;\n    var handleOffset = handleElement.offsetWidth;\n    var wrapper = this._wrapper;\n    var rtl = wrapper && getComputedStyle(wrapper).direction === 'rtl' || false;\n    var rect = wrapper.getBoundingClientRect();\n    var wrapperOffset = wrapper.offsetWidth;\n\n    if (wrapperOffset === 0) {\n      return;\n    }\n\n    this._controller.updateState({\n      animate: false,\n      checked: this.state.checked,\n      coords: {\n        left: rect.left,\n        right: rect.right\n      },\n      handleMargin: handleMargin,\n      handleOffset: handleOffset,\n      reverse: rtl,\n      wrapperOffset: wrapperOffset\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Switch.propTypes = {\n    checked: PropTypes.bool,\n    className: PropTypes.string,\n    disabled: PropTypes.bool,\n    defaultChecked: PropTypes.bool,\n    dir: PropTypes.string,\n    id: PropTypes.string,\n    offLabel: PropTypes.string,\n    onBlur: PropTypes.any,\n    onChange: PropTypes.any,\n    onFocus: PropTypes.any,\n    onLabel: PropTypes.string,\n    tabIndex: PropTypes.number\n  };\n  /**\n   * @hidden\n   */\n\n  Switch.defaultProps = {\n    disabled: false,\n    defaultChecked: false,\n    offLabel: 'OFF',\n    onBlur: noop,\n    onFocus: noop,\n    onLabel: 'ON',\n    tabIndex: 0\n  };\n  return Switch;\n}(React.Component);\n\nexport default Switch;","map":null,"metadata":{},"sourceType":"module"}